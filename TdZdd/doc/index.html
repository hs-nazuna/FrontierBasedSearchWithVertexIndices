<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>TdZdd: TdZdd User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">TdZdd
   &#160;<span id="projectnumber">1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">TdZdd User Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#dd-specification">DD specification</a></li>
<li><a href="#operations-on-dd-specifications">Operations on DD specifications</a></li>
<li><a href="#dd-structure">DD structure</a></li>
</ul>
<hr/>
<p> <a class="anchor" id="overview"></a> </p><h1>Overview </h1>
<p>A DD has one root node and two terminal nodes (⊤ and ⊥). Every non-terminal node of an <em>N</em>-ary DD has <em>N</em> outgoing edges.</p>
<div class="image">
<img src="example1.png" alt="example1.png"/>
<div class="caption">
An example of binary DD</div></div>
<p> The above picture shows an example of binary DD structure, where the ⊥ terminal node and all edges to it are omitted for visibility; dashed and solid lines are 0- and 1-edges respectively. The DD represents a set of all 3-combinations out of 5 items. Note that levels of DD nodes are defined in descending order; the root node has the highest level and the terminal nodes have the lowest.</p>
<p>The following code from <a href="../apps/test/example1.cpp">apps/test/example1.cpp</a> is a <em>DD specification</em> of a binary DD structure representing a set of all <em>k</em>-combinations out of <em>n</em> items.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Combination: <span class="keyword">public</span> <a class="code" href="classtdzdd_1_1DdSpec.html">tdzdd::DdSpec</a>&lt;Combination,int,2&gt; {</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> n;</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> k;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Combination(<span class="keywordtype">int</span> n, <span class="keywordtype">int</span> k)</div>
<div class="line">            : n(n), k(k) {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> getRoot(<span class="keywordtype">int</span>&amp; state)<span class="keyword"> const </span>{</div>
<div class="line">        state = 0;</div>
<div class="line">        <span class="keywordflow">return</span> n;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> getChild(<span class="keywordtype">int</span>&amp; state, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> value)<span class="keyword"> const </span>{</div>
<div class="line">        state += value;</div>
<div class="line">        <span class="keywordflow">if</span> (--level == 0) <span class="keywordflow">return</span> (state == k) ? -1 : 0;</div>
<div class="line">        <span class="keywordflow">if</span> (state &gt; k) <span class="keywordflow">return</span> 0;</div>
<div class="line">        <span class="keywordflow">if</span> (state + level &lt; k) <span class="keywordflow">return</span> 0;</div>
<div class="line">        <span class="keywordflow">return</span> level;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>Class <code>Combination</code> inherits from <code><a class="el" href="classtdzdd_1_1DdSpec.html" title="Abstract class of DD specifications using scalar states. ">tdzdd::DdSpec</a>&lt;Combination,int,2&gt;</code>, of which the first template parameter is the derived class itself, the second one is the type of its <em>state</em>, and the third one declares the out-degree of non-terminal DD nodes (<em>N</em>). The class contains public member functions <code>int getRoot(int&amp; state)</code> and <code>int getChild(int&amp; state, int level, int value)</code>.</p>
<p><code>getRoot</code> initializes the <code>state</code> argument by the state of the root node and returns its level. <code>getChild</code> receives <code>state</code> and <code>level</code> of a non-terminal node and integer <code>value</code> in the range [0, <em>N</em>-1] selecting one of the <em>N</em> branches. It computes the state and the level of the child node. If the child node is not a terminal, it updates <code>state</code> and returns the level. If the child node is ⊥ or ⊤, it returns 0 or -1 respectively; <code>state</code> is not used in those cases.</p>
<p>A DD represented by a DD specification can be dumped in "dot" format for <a href="http://www.graphviz.org/">Graphviz</a> visualization tools.</p>
<div class="fragment"><div class="line">Combination spec(5, 2);</div>
<div class="line">spec.dumpDot(std::cout);</div>
</div><!-- fragment --><p><code><a class="el" href="classtdzdd_1_1DdStructure.html" title="Ordered n-ary decision diagram structure. ">tdzdd::DdStructure</a>&lt;2&gt;</code> is a class of explicit binary DD structures. Its object can be constructed from a DD specification object.</p>
<div class="fragment"><div class="line"><a class="code" href="classtdzdd_1_1DdStructure.html">tdzdd::DdStructure&lt;2&gt;</a> dd(spec);</div>
</div><!-- fragment --><p>A DD structrue can be reduced as a BDD or ZDD using its <code>void bddReduce()</code> or <code>void zddReduce()</code> member function, and also can be dumped in "dot" format.</p>
<div class="fragment"><div class="line">dd.<a class="code" href="classtdzdd_1_1DdStructure.html#a4bb6b7ebb872ca622b10ca3b02c3bd07">zddReduce</a>();</div>
<div class="line">dd.<a class="code" href="classtdzdd_1_1DdSpecBase.html#ab77ef493d44d50ae0ffbd571c62c77af">dumpDot</a>(std::cout);</div>
</div><!-- fragment --><p>A DD structure can be evaluated from the bottom to the top. The following code from <a href="../apps/test/testSizeConstraint.cpp">apps/test/testSizeConstraint.cpp</a> is a <em>DD evaluator</em> to find the size of the largest itemset represented by a ZDD.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MaxNumItems: <span class="keyword">public</span> <a class="code" href="classtdzdd_1_1DdEval.html">tdzdd::DdEval</a>&lt;MaxNumItems,int&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> evalTerminal(<span class="keywordtype">int</span>&amp; n, <span class="keywordtype">bool</span> one)<span class="keyword"> const </span>{</div>
<div class="line">        n = one ? 0 : INT_MIN;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> evalNode(<span class="keywordtype">int</span>&amp; n, <span class="keywordtype">int</span>, DdValues&lt;int,2&gt; <span class="keyword">const</span>&amp; values)<span class="keyword"> const </span>{</div>
<div class="line">        n = std::max(values.get(0), values.get(1) + 1);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>It is used as follows.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> max = dd.<a class="code" href="classtdzdd_1_1DdStructure.html#a665dc9108902aeee588866944a4e7960">evaluate</a>(MaxNumItems());</div>
</div><!-- fragment --><p>The construction and evaluation functions can also be used easily to implement import and export functions of DD structures from/to other DD libraries.</p>
<hr/>
<p> <a class="anchor" id="dd-specification"></a> </p><h1>DD specification </h1>
<p>A DD specification is defined by deriving it from an appropriate one of the base classes defined in &lt;<a class="el" href="DdSpec_8hpp.html">tdzdd/DdSpec.hpp</a>&gt;.</p>
<p>Every DD specification must have <code>getRoot</code> and <code>getChild</code> member functions. <code>getRoot</code> defines the root node configuration. <code>getChild</code> defines a mapping from parent node configurations to child node configurations. If the node is not a terminal, the functions update state information and return a positive integer representing the node level. If the node is ⊥ or ⊤, they simply return 0 or -1 respectively for convenience, even though both nodes are level 0. We refer to such a return value as a <em>level code</em>.</p>
<h2>DdSpec </h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="DdSpec_8hpp.html">tdzdd/DdSpec.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">class </span>S: <span class="keyword">public</span> <a class="code" href="classtdzdd_1_1DdSpec.html">tdzdd::DdSpec</a>&lt;S,T,N&gt; { ... };</div>
</div><!-- fragment --><p> is an <em>N</em>-ary DD specification using type <code>T</code> to store state information. Class <code>S</code> must implement the following member functions:</p>
<ul>
<li><code>int getRoot(T&amp; state)</code> stores state information of the root node into <code>state</code> and returns a level code.</li>
<li><code>int getChild(T&amp; state, int level, int value)</code> receives state information of a non-terminal node via <code>state</code>, the level of it via <code>level</code>, and a branch label in the range [0, <em>N</em>-1] via <code>value</code>; updates <code>state</code> by state information of the child node and returns a level code.</li>
</ul>
<p>In addition, <code>S</code> may have to override the following member functions:</p>
<ul>
<li><code>bool equalTo(T const&amp; state1, T const&amp; state2)</code> returns if <code>state1</code> and <code>state2</code> are equivalent. The default implementation is <code>state1 == state2</code>.</li>
<li><code>size_t hashCode(T const&amp; state)</code> computes a hash value for <code>state</code>. The default implementation is <code>static_cast&lt;size_t&gt;(state)</code>.</li>
</ul>
<p>Hash values for any two states must be the same whenever they are equivalent. As shown in <a href="#overview">Overview</a>, we can use the default implementations and do not need to override them when <code>T</code> is a fundamental data type such as <code>int</code>.</p>
<h2>PodArrayDdSpec </h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="DdSpec_8hpp.html">tdzdd/DdSpec.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">class </span>S: <span class="keyword">public</span> <a class="code" href="classtdzdd_1_1PodArrayDdSpec.html">tdzdd::PodArrayDdSpec</a>&lt;S,T,N&gt; { ... };</div>
</div><!-- fragment --><p> is an <em>N</em>-ary DD specification using an array of type <code>T</code> to store state information. The size of the array must be fixed to some positive integer <em>m</em> by calling predefined function <code>setArraySize(m)</code> in the constructor of <code>S</code>. The library handles the state information just as (<code>sizeof(T)</code> × <em>m</em>)-byte raw data for efficiency; therefore, <code>T</code> must be a data structure without object-oriented features (user-defined constructor, destructor, copy-assignment, etc.). Class <code>S</code> must implement the following member functions:</p>
<ul>
<li><code>int getRoot(T* array)</code> stores state information of the root node into <code>array[0]</code>..<code>array[m-1]</code> and returns a level code.</li>
<li><code>int getChild(T* array, int level, int value)</code> receives state information of a non-terminal node via <code>array[0]</code>..<code>array[m-1]</code>, the level of it via <code>level</code>, and a branch label in the range [0, <em>N</em>-1] via <code>value</code>; updates <code>array[0]</code>..<code>array[m-1]</code> by state information of the child node and returns a level code.</li>
</ul>
<p>You can find an example in <a href="../apps/test/example2.cpp">apps/test/example2.cpp</a>.</p>
<h2>HybridDdSpec </h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="DdSpec_8hpp.html">tdzdd/DdSpec.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">class </span>S: <span class="keyword">public</span> <a class="code" href="classtdzdd_1_1HybridDdSpec.html">tdzdd::HybridDdSpec</a>&lt;S,TS,TA,N&gt; { ... };</div>
</div><!-- fragment --><p> is an <em>N</em>-ary DD specification using a combination of type <code>TS</code> and an array of type <code>TA</code> to store state information. The size of the array must be fixed to some positive integer <em>m</em> by calling predefined function <code>setArraySize(m)</code> in the constructor of <code>S</code>. The library handles the state information of the array just as (<code>sizeof(TA)</code> × <em>m</em>)-byte raw data for efficiency; therefore, <code>TA</code> must be a data structure without object-oriented features (user-defined constructor, destructor, copy-assignment, etc.). Class <code>S</code> must implement the following member functions:</p>
<ul>
<li><code>int getRoot(TS&amp; scalar, TA* array)</code> stores state information of the root node into <code>scalar</code> as well as <code>array[0]</code>..<code>array[m-1]</code> and returns a level code.</li>
<li><code>int getChild(TS&amp; scalar, TA* array, int level, int value)</code> receives state information of a non-terminal node via <code>scalar</code> and <code>array[0]</code>..<code>array[m-1]</code>, the level of it via <code>level</code>, and a branch label in the range [0, <em>N</em>-1] via <code>value</code>; updates <code>scalar</code> and <code>array[0]</code>..<code>array[m-1]</code> by state information of the child node and returns a level code.</li>
</ul>
<h2>StatelessDdSpec </h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="DdSpec_8hpp.html">tdzdd/DdSpec.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">class </span>S: <span class="keyword">public</span> <a class="code" href="classtdzdd_1_1StatelessDdSpec.html">tdzdd::StatelessDdSpec</a>&lt;S,N&gt; { ... };</div>
</div><!-- fragment --><p> is an <em>N</em>-ary DD specification using no state information, which means that the DD does not have more than one node at any non-terminal level. Class <code>S</code> must implement the following member functions:</p>
<ul>
<li><code>int getRoot()</code> returns a level code of the root node.</li>
<li><code>int getChild(int level, int value)</code> receives level of a non-terminal node via <code>level</code> and a branch label in the range [0, <em>N</em>-1] via <code>value</code>; returns a level code of the child node.</li>
</ul>
<p>The next example is a specification of a ZDD for a family of all singletons out of <em>n</em> items.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="DdSpec_8hpp.html">tdzdd/DdSpec.hpp</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>SingletonZdd: <span class="keyword">public</span> <a class="code" href="classtdzdd_1_1StatelessDdSpec.html">tdzdd::StatelessDdSpec</a>&lt;SingletonZdd,2&gt; {</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span> n;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    SingletonZdd(<span class="keywordtype">int</span> n)</div>
<div class="line">            : n(n) {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> getRoot()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> n;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> getChild(<span class="keywordtype">int</span> level, <span class="keywordtype">int</span> value)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (value) <span class="keywordflow">return</span> -1;</div>
<div class="line">        <span class="keywordflow">return</span> level - 1;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2>DdSpecBase </h2>
<p>Every DD specification inherits from <code><a class="el" href="classtdzdd_1_1DdSpecBase.html" title="Base class of DD specs. ">tdzdd::DdSpecBase</a>&lt;S,N&gt;</code>, which defines common member functions including the one to generate a "dot" file for <a href="http://www.graphviz.org/">Graphviz</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classtdzdd_1_1DdSpecBase.html#ab77ef493d44d50ae0ffbd571c62c77af">tdzdd::DdSpecBase&lt;S,N&gt;::dumpDot</a>(std::ostream&amp; os = std::cout, std::string title = tdzdd::typenameof&lt;S&gt;()) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>Each DD specification may have to define its own <code>printState</code> member function that prints text on each DD nodes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classtdzdd_1_1DdSpecBase.html">tdzdd::DdSpecBase&lt;S,N&gt;::printState</a>(std::ostream&amp; os, T <span class="keyword">const</span>&amp; state) <span class="keyword">const</span>; <span class="comment">// for DdSpec</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classtdzdd_1_1DdSpecBase.html">tdzdd::DdSpecBase&lt;S,N&gt;::printState</a>(std::ostream&amp; os, T <span class="keyword">const</span>* array) <span class="keyword">const</span>; <span class="comment">// for PodArrayDdSpec</span></div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classtdzdd_1_1DdSpecBase.html">tdzdd::DdSpecBase&lt;S,N&gt;::printState</a>(std::ostream&amp; os, TS <span class="keyword">const</span>&amp; scalar, TA <span class="keyword">const</span>* array) <span class="keyword">const</span>; <span class="comment">// for HybridDdSpec</span></div>
</div><!-- fragment --><p>Text of each level can also be customized by overriding <code>printLevel</code> member function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classtdzdd_1_1DdSpecBase.html#a52c50e764aae54e24335f2517ad24493">tdzdd::DdSpecBase&lt;S,N&gt;::printLevel</a>(std::ostream&amp; os, <span class="keywordtype">int</span> level) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p>The default implementation prints the <code>level</code> itself.</p>
<hr/>
<p> <a class="anchor" id="operations-on-dd-specifications"></a> </p><h1>Operations on DD specifications </h1>
<p>Operations on DD specifications are defined as global functions in &lt;<a class="el" href="DdSpecOp_8hpp.html">tdzdd/DdSpecOp.hpp</a>&gt;. Note that they are also applicable to DD structures.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S1, <span class="keyword">typename</span> S2&gt;</div>
<div class="line">tdzdd::BddAnd&lt;S1,S2&gt; <a class="code" href="namespacetdzdd.html#a10e3d2a34c7b9f8686c3d8541e622de3">tdzdd::bddAnd</a>(S1 <span class="keyword">const</span>&amp; spec1, S2 <span class="keyword">const</span>&amp; spec2);</div>
</div><!-- fragment --><p> returns a BDD specification for logical AND of two BDD specifications.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S1, <span class="keyword">typename</span> S2&gt;</div>
<div class="line">tdzdd::BddOr&lt;S1,S2&gt; <a class="code" href="namespacetdzdd.html#a0a0b1c53810d287a3fbecf6844810396">tdzdd::bddOr</a>(S1 <span class="keyword">const</span>&amp; spec1, S2 <span class="keyword">const</span>&amp; spec2);</div>
</div><!-- fragment --><p> returns a BDD specification for logical OR of two BDD specifications.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S1, <span class="keyword">typename</span> S2&gt;</div>
<div class="line">tdzdd::ZddIntersection&lt;S1,S2&gt; <a class="code" href="namespacetdzdd.html#a9e7b0051ec4796942c31f215d3f6f9f4">tdzdd::zddIntersection</a>(S1 <span class="keyword">const</span>&amp; spec1, S2 <span class="keyword">const</span>&amp; spec2);</div>
</div><!-- fragment --><p> returns a ZDD specification for set intersection of two ZDD specifications.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S1, <span class="keyword">typename</span> S2&gt;</div>
<div class="line">tdzdd::ZddUnion&lt;S1,S2&gt; <a class="code" href="namespacetdzdd.html#a75dca1bfa26169b67a916b64b46400c8">tdzdd::zddUnion</a>(S1 <span class="keyword">const</span>&amp; spec1, S2 <span class="keyword">const</span>&amp; spec2);</div>
</div><!-- fragment --><p> returns a ZDD specification for set union of two ZDD specifications.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S&gt;</div>
<div class="line">tdzdd::BddLookahead&lt;S&gt; <a class="code" href="namespacetdzdd.html#a5a60c875d7b8981d8a520ab5c58b2915">tdzdd::bddLookahead</a>(S <span class="keyword">const</span>&amp; spec);</div>
</div><!-- fragment --><p> optimizes a BDD specification in terms of the BDD node deletion rule.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S&gt;</div>
<div class="line">tdzdd::ZddLookahead&lt;S&gt; <a class="code" href="namespacetdzdd.html#a7bf53d61e3a320798cd42ce3a3249e3d">tdzdd::zddLookahead</a>(S <span class="keyword">const</span>&amp; spec);</div>
</div><!-- fragment --><p> optimizes a ZDD specification in terms of the ZDD node deletion rule.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S&gt;</div>
<div class="line">tdzdd::BddUnreduction&lt;S&gt; <a class="code" href="namespacetdzdd.html#a169ae458ab7eef5039c2a375cce557a1">tdzdd::bddUnreduction</a>(S <span class="keyword">const</span>&amp; spec, <span class="keywordtype">int</span> numVars);</div>
</div><!-- fragment --><p> creates a QDD specification from a BDD specification by complementing skipped nodes in terms of the BDD node deletion rule.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S&gt;</div>
<div class="line">tdzdd::ZddUnreduction&lt;S&gt; <a class="code" href="namespacetdzdd.html#a200a5f4ec299357e5352b621e2a0fe2c">tdzdd::zddUnreduction</a>(S <span class="keyword">const</span>&amp; spec, <span class="keywordtype">int</span> numVars);</div>
</div><!-- fragment --><p> creates a QDD specification from a ZDD specification by complementing skipped nodes in terms of the ZDD node deletion rule.</p>
<hr/>
<p> <a class="anchor" id="dd-structure"></a> </p><h1>DD structure </h1>
<p>The template class of DD structures is defined in &lt;<a class="el" href="DdStructure_8hpp.html">tdzdd/DdStructure.hpp</a>&gt;.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span> N&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code" href="classtdzdd_1_1DdStructure.html">tdzdd::DdStructure</a>;</div>
</div><!-- fragment --><p>Note that <code>DdStructure&lt;N&gt;</code> works also as the DD specification that represent itself.</p>
<h2>Construction </h2>
<p>A DD structure can be constructed from a DD specification using the following templated constructor.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S&gt;</div>
<div class="line"><a class="code" href="classtdzdd_1_1DdStructure.html#ac561da82fa26d860e4b29b864ccab347">tdzdd::DdStructure&lt;N&gt;::DdStructure</a>(tdzdd::DdSpecBase&lt;S,N&gt; <span class="keyword">const</span>&amp; spec, <span class="keywordtype">bool</span> useMP = <span class="keyword">false</span>);</div>
</div><!-- fragment --><p>The optional argument <code>useMP</code> sets the attribute value of the object that enables OpenMP parallel processing. Note that the parallel algorithms are tuned for fairly large DDs and may not be very effective on small DDs.</p>
<p>The default constructor of <code><a class="el" href="classtdzdd_1_1DdStructure.html" title="Ordered n-ary decision diagram structure. ">tdzdd::DdStructure</a>&lt;N&gt;</code> creates a new DD representing ⊥. </p><div class="fragment"><div class="line"><a class="code" href="classtdzdd_1_1DdStructure.html#ac561da82fa26d860e4b29b864ccab347">tdzdd::DdStructure&lt;N&gt;::DdStructure</a>();</div>
</div><!-- fragment --><p>The next one constructs a new DD with <em>n</em> non-terminal nodes at levels <em>n</em> to 1, of which each one has <em>N</em> edges pointing to the same node at the next lower level. </p><div class="fragment"><div class="line"><a class="code" href="classtdzdd_1_1DdStructure.html#ac561da82fa26d860e4b29b864ccab347">tdzdd::DdStructure&lt;N&gt;::DdStructure</a>(<span class="keywordtype">int</span> n, <span class="keywordtype">bool</span> useMP = <span class="keyword">false</span>);</div>
</div><!-- fragment --><p> When <em>N</em> = 2, it is a ZDD for the power set of a set of <em>n</em> items.</p>
<h2>Subsetting </h2>
<p>TdZdd provides an efficient method, called <em>ZDD subsetting</em>, to refine an existing ZDD by adding a constraint given as a DD specification.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> S&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classtdzdd_1_1DdStructure.html#a1bf772295a1a856b4895948129241b07">tdzdd::DdStructure&lt;N&gt;::zddSubset</a>(tdzdd::DdSpecBase&lt;S,N&gt; <span class="keyword">const</span>&amp; spec);</div>
</div><!-- fragment --><p> This templated member function of <code><a class="el" href="classtdzdd_1_1DdStructure.html" title="Ordered n-ary decision diagram structure. ">tdzdd::DdStructure</a>&lt;N&gt;</code> updates the current DD by a new DD for ZDD intersection of itself and the given DD specification. The original DD should be reduced as a ZDD in advance for this function to work efficiently.</p>
<h2>Reduction </h2>
<p>The following member functions of <code><a class="el" href="classtdzdd_1_1DdStructure.html" title="Ordered n-ary decision diagram structure. ">tdzdd::DdStructure</a>&lt;N&gt;</code> apply reduction rules to the current DD structure.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classtdzdd_1_1DdStructure.html#a906ac6309504626a7280939db254a4dc">tdzdd::DdStructure&lt;N&gt;::qddReduce</a>();</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classtdzdd_1_1DdStructure.html#a2d874897e34161f470d6c3693d4524f6">tdzdd::DdStructure&lt;N&gt;::bddReduce</a>();</div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="classtdzdd_1_1DdStructure.html#a4bb6b7ebb872ca622b10ca3b02c3bd07">tdzdd::DdStructure&lt;N&gt;::zddReduce</a>();</div>
</div><!-- fragment --><p><code>qddReduce()</code> applies the node sharing rule only. <code>bddReduce()</code> applies the node sharing rule and the BDD node deletion rule, which deletes a node when all its outgoing edges point to the same child. <code>zddReduce()</code> applies the node sharing rule and the ZDD node deletion rule, which deletes a node when all of its non-zero-labeled outgoing edges point to ⊥.</p>
<h2>Evaluation </h2>
<p>A DD evaluator can be defined by deriving it from <code><a class="el" href="classtdzdd_1_1DdEval.html" title="Base class of DD evaluators. ">tdzdd::DdEval</a>&lt;E,T&gt;</code> defined in &lt;<a href="../include/tdzdd/DdSpec.hpp">tdzdd/DdSpec.hpp</a>&gt;.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="DdEval_8hpp.html">tdzdd/DdEval.hpp</a>&gt;</span></div>
<div class="line"><span class="keyword">class </span>E: <span class="keyword">public</span> <a class="code" href="classtdzdd_1_1DdEval.html">tdzdd::DdEval</a>&lt;E,T&gt; { ... };</div>
</div><!-- fragment --><p> defines the DD evaluator <em>E</em> that computes a value of type <em>T</em>.</p>
<p>A <code>tdzdd::DDStructure&lt;N&gt;</code> object can be evaluated by <em>E</em> as follows. </p><div class="fragment"><div class="line"><a class="code" href="classtdzdd_1_1DdStructure.html">tdzdd::DdStructure&lt;N&gt;</a> dd = ... ;</div>
<div class="line">T value = dd.<a class="code" href="classtdzdd_1_1DdStructure.html#a665dc9108902aeee588866944a4e7960">evaluate</a>(E());</div>
</div><!-- fragment --><p>Every DD evaluator must define the following functions:</p>
<ul>
<li><code>void evalTerminal(T&amp; v, int id)</code> receives a terminal node identifier (0 or 1) via <code>id</code> and writes the value for it into <code>v</code>.</li>
<li><code>void evalNode(T&amp; v, int level, <a class="el" href="classtdzdd_1_1DdValues.html" title="Collection of child node values/levels for DdEval::evalNode function interface. ">tdzdd::DdValues</a>&lt;T,N&gt; const&amp; values)</code> receives the <code>level</code> of the node to be evaluated and evaluation results for its child nodes via <code>values</code>; writes the result value into <code>v</code>.</li>
</ul>
<p>In <code>evalNode</code>, the value and level of the <em>b</em>-th child node (<em>b</em> = 0..*N*-1) can be obtained through <code>values.get(b)</code> and <code>values.getLevel(b)</code> respectively.</p>
<h2>Utility functions </h2>
<p>The following member functions of <code><a class="el" href="classtdzdd_1_1DdStructure.html" title="Ordered n-ary decision diagram structure. ">tdzdd::DdStructure</a>&lt;N&gt;</code> might be also useful.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="classtdzdd_1_1DdStructure.html#ac5c48d6fa28ef9926a53c6d8beef9675">tdzdd::DdStructure&lt;N&gt;::topLevel</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> gets the level of the root node.</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> <a class="code" href="classtdzdd_1_1DdStructure.html#a632c559161fb9af5e24ceeb275c870a9">tdzdd::DdStructure&lt;N&gt;::size</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> gets the number of nonterminal nodes.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classtdzdd_1_1DdStructure.html#ad00784e7df35d74edd733181cd150095">tdzdd::DdStructure&lt;N&gt;::operator==</a>(<a class="code" href="classtdzdd_1_1DdStructure.html">tdzdd::DdStructure&lt;N&gt;</a> <span class="keyword">const</span>&amp; o) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> checks structural equivalence with another DD. Compare after reduction if you want to check logical equivalence.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="classtdzdd_1_1DdStructure.html#a7281fe5cff4cd1216f4bf7332ffc917c">tdzdd::DdStructure&lt;N&gt;::operator!=</a>(<a class="code" href="classtdzdd_1_1DdStructure.html">tdzdd::DdStructure&lt;N&gt;</a> <span class="keyword">const</span>&amp; o) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> checks structural inequivalence with another DD. Compare after reduction if you want to check logical inequivalence.</p>
<div class="fragment"><div class="line"><a class="code" href="classtdzdd_1_1DdStructure.html">tdzdd::DdStructure&lt;N&gt;</a> <a class="code" href="classtdzdd_1_1DdStructure.html#a20b1a1c3cbdda3c0bf93e7c94d6332c9">tdzdd::DdStructure&lt;N&gt;::bdd2zdd</a>(<span class="keywordtype">int</span> numVars) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> transforms a BDD into a ZDD.</p>
<div class="fragment"><div class="line"><a class="code" href="classtdzdd_1_1DdStructure.html">tdzdd::DdStructure&lt;N&gt;</a> <a class="code" href="classtdzdd_1_1DdStructure.html#a8a563c4b063b3e6d85403c42269d58d8">tdzdd::DdStructure&lt;N&gt;::zdd2bdd</a>(<span class="keywordtype">int</span> numVars) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> transforms a ZDD into a BDD.</p>
<div class="fragment"><div class="line">std::string <a class="code" href="classtdzdd_1_1DdStructure.html#a43c2949a18453056af1b967ca3931b94">tdzdd::DdStructure&lt;N&gt;::bddCardinality</a>(<span class="keywordtype">int</span> numVars) <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> counts the number of minterms of the function represented by this BDD.</p>
<div class="fragment"><div class="line">std::string <a class="code" href="classtdzdd_1_1DdStructure.html#a54f85cde2031c53a29ff4f2873196418">tdzdd::DdStructure&lt;N&gt;::zddCardinality</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> counts the number of itemsets in the family of itemsets represented by this ZDD.</p>
<div class="fragment"><div class="line"><a class="code" href="classtdzdd_1_1DdStructure_1_1const__iterator.html">tdzdd::DdStructure&lt;N&gt;::const_iterator</a> <a class="code" href="classtdzdd_1_1DdStructure.html#ad68919761e9fbbcb471147c565f1ba78">tdzdd::DdStructure&lt;N&gt;::begin</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> returns an iterator to the first element of the family of itemsets represented by this ZDD. Each itemset is represented by <code>std::set&lt;int&gt;</code> of levels of selected items.</p>
<div class="fragment"><div class="line"><a class="code" href="classtdzdd_1_1DdStructure_1_1const__iterator.html">tdzdd::DdStructure&lt;N&gt;::const_iterator</a> <a class="code" href="classtdzdd_1_1DdStructure.html#a8a635dd78162f07c06fe9c55312c17a9">tdzdd::DdStructure&lt;N&gt;::end</a>() <span class="keyword">const</span>;</div>
</div><!-- fragment --><p> returns an iterator to the element following the last element of the family of itemsets represented by this ZDD. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 4 2016 14:23:15 for TdZdd by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
